<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

# Strassen - Strassen算法

--------

#### 问题

用Strassen算法计算两个$$ n $$阶矩阵相乘。

#### 基础概念

//1)基础概念
//矩阵：m*n个数字组成的m行n列的表格，第i行第j列的元素为a(i,j)，其中1<=i<=m，1<=j<=n
//零矩阵：所有元素都是0的矩阵
//矩阵相等：矩阵A=B当且仅当A和B的行列数相等，且对应的每一个元素都相等
//n阶矩阵：n*n的矩阵
//n阶矩阵的主对角线：即所有元素a(i,i)，其中1<=i<=n
//上三角矩阵：主对角线以下(不包括主对角线)的元素都为0
//下三角矩阵：主对角线以上(不包括主对角线)的元素都为0
//单位矩阵：n阶矩阵中，主对角线上的元素都是1，其余元素都是0，称为n阶单位矩阵，简写作E
//转置矩阵：矩阵A的转置矩阵是n*m矩阵AT，AT中的每个元素at(j,i)等于矩阵A中的元素a(i,j)
//对称矩阵：若A的转置矩阵AT = A，则A是对称矩阵
//反对称矩阵：若A的转置矩阵AT = -A，即at(j,i) = -a(i,j)，则A为反对称矩阵
//对角矩阵：n阶矩阵A中主对角线以外的其余元素都是0，则A为对角矩阵
//线性无关，线性有关：
//矩阵中某一行无法经过其他行的加减乘除运算变换得到，则该行与其他行线性无关
//若某一行出现这样的情况：第i行可以由第j,k...行乘除常数，相加减得到
//则称该矩阵可以经过初等变换，可以转化为拥有全为0的一行，该行与其他行是线性有关的
//矩阵的秩：矩阵中任意行或列之间线性无关的行数或列数即为矩阵的秩，记作r
//经过有限次初等变换矩阵中线性有关的行或列可以被转化为全为0的行或列
//不全为0的行和列的数量即为矩阵的秩，经过初等变换不存在全0的行或列的矩阵称为满秩矩阵
//逆矩阵：n阶矩阵A存在一个对应的n阶矩阵B，使得AB = BA = E
//则称A是可逆矩阵，B是A的逆矩阵，且A的逆矩阵B唯一，记为A(-1)
//正定矩阵：
//设A是n阶矩阵，x是任意n维向量，xt是x的转置，若对于任意的x != 0都有 xt*A*x > 0
//则称A是正定矩阵
//
//矩阵加减：
//能够进行加减运算的两矩阵必须有相等的行和列，m*n的矩阵A+B=C(或A-B=C)
//C中元素c(i,j) = a(i,j) + b(i,j)(或c(i,j)=a(i,j)-b(i,j))，其中1<=i<=m，1<=j<=n
//矩阵数乘：
//矩阵A与常数c相乘得到矩阵B，B中元素b(i,j) = c*a(i,j)
//矩阵乘：
//能够进行乘运算的矩阵A和B必须A的列与B的行相等
//即A是m*s的矩阵，B是s*n的矩阵，A*B=C，得到的矩阵C是m*n的矩阵
//C中元素c(i,j) = a(i,1)*b(1,j) + a(i,2)*b(2,j) + ... + a(i,s)*b(s,j)
//其中1<=i<=m，1<=j<=n
//
//2)具体实现
//Strassen算法用于求解两n阶矩阵相乘，时间复杂度比普通的数学方法低
//该算法主要使用了分而治之的算法思想，以及对矩阵相乘中的计算进行巧妙的优化
//考虑两n阶矩阵X和Y相乘得到Z，即Z=XY，假设n为偶数，将XYZ都划分为n/2*n/2的矩阵
//则这三个矩阵可转化为： |r  s| = |a  b|*|e  f|
//						 |t  u|	  |c  d| |g  h|
//其中每个元素都是一个n/2*n/2的子矩阵，按照普通的矩阵乘法规则可知：
//r = ae + bg
//s = af + bh
//t = ce + dg
//u = cf + dh
//从上式可以看出，求解rstu中每一个子矩阵，都需要计算两次矩阵相乘
//比如r = ae + bg需要计算a*e和b*g，因此得到一个矩阵需要计算8次子矩阵的相乘
//通过递归的求解每个矩阵的子矩阵，是分而治之策略，该方法的时间复杂度是O(n^3)
//但Strassen算法只需要递归的计算7个子矩阵，使得时间复杂度下降到O(n^2.81)
//设置7个中间矩阵，从P1到P7，其中：
//P1 = af - ah = a(f - h)
//P2 = ah + bh = (a + b)h
//P3 = ce + de = (c + d)e
//P4 = dg - de = d(g - e)
//P5 = ae + ah + de + dh = (a + d)(e + h)
//P6 = bg + bh - dg - dh = (b - d)(g + h)
//P7 = ae + af - ce - cf = (a - c)(e + f)
//又有：
//r = P5 + P4 - P2 + P6
//s = P1 + P2
//t = P3 + p4
//u = P1 + P5 - P3 - P7
//由此，添加了若干子矩阵的加减运算，但得到一个矩阵只需要进行7次子矩阵的相乘
//为了方便本文中只考虑n为偶数的矩阵相乘，若n为奇数则子矩阵的划分总是多出一行一列
//实际中该算法由于增加了过多的矩阵加减运算，其实际效率并不高
//
//本节引用了“数学复习全书(2013年李永乐李正元考研数学 数学一)”，作者“李永乐”“李正元”


现有$$ n $$个珠宝，已知第$$ i $$个珠宝的价值是$$ v_{i} $$，重量是$$ w_{i} $$。给你一个背包，你可以自由挑选珠宝装到背包中，但背包可以装载的最大重量为$$ weight $$。求背包能够装载珠宝的最大价值$$ value $$。

#### 解法

设$$ f(i,j) $$为背包中放入前$$ i $$件物品，重量不大于$$ j $$的最大价值，其中$$ i \in [1,n] $$，$$ j \in [0,weight] $$。有如下状态转移方程：

$$
f(i,j) =

\begin{cases}
0                                               &   (initialize)    &   i \in [0,n], j \in [0, weight]  \\
max( f(i-1,j), f(i - 1, j - w_{i}) + v_{i})     &   (loop)          &   i \in [1,n], j \in [0,weight], j \geq w_{i}
\end{cases}
$$

$$ (1) $$ 初始化，背包中没有放入任何珠宝时$$ f(i,j) = 0 $$；

$$ (2) $$ 对于第$$ i $$个珠宝$$ s_{i} $$，若装入背包，则背包价值增大$$ v_{i} $$，背包的剩余重量（还能装载的重量）减小$$ w_{i} $$，即$$ f(i,j) = f(i-1,j-w_{i})+v_{i} $$（其中$$ j \geq w_{i} $$）；若不装入背包，则一切维持不变，即$$ f(i,j) = f(i-1,j) $$。选择这两种情形中的最大值；

$$ f(n,weight) $$即为$$ n $$个珠宝中重量不超过$$ weight $$的最大价值。该算法的时间复杂度是$$ O(n \times weight) $$。

--------

#### 源码

[Strassen.h](https://github.com/linrongbin16/Way-to-Algorithm/blob/master/src/LinearAlgebra/Matrix/Strassen.h)

[Strassen.cpp](https://github.com/linrongbin16/Way-to-Algorithm/blob/master/src/LinearAlgebra/Matrix/Strassen.cpp)

#### 测试

[StrassenTest.cpp](https://github.com/linrongbin16/Way-to-Algorithm/blob/master/src/LinearAlgebra/Matrix/StrassenTest.cpp)

